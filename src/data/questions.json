{
  "categories": {
    "javascript": {
      "name": "JavaScript",
      "description": "Core JavaScript concepts and modern features",
      "icon": "fab fa-js-square",
      "hints": [
        {
          "id": "js-1",
          "title": "Difference between == and ===",
          "content": "== allows type coercion (e.g., '5' == 5 returns true), while === checks both value and type strictly (e.g., '5' === 5 returns false). Always use === for predictable comparisons."
        },
        {
          "id": "js-2",
          "title": "Arrow Functions vs Regular Functions",
          "content": "Arrow functions don't have their own 'this' binding - they inherit 'this' from the parent scope. They also can't be used as constructors and don't have a 'prototype' property."
        },
        {
          "id": "js-3",
          "title": "Closures",
          "content": "A closure is when a function 'remembers' its lexical scope even when executed outside that scope. This allows functions to access variables from their outer scope."
        },
        {
          "id": "js-4",
          "title": "Promises",
          "content": "Promises represent asynchronous operations with three states: pending, resolved, or rejected. Use .then() for success and .catch() for errors, or async/await for cleaner syntax."
        },
        {
          "id": "js-5",
          "title": "Spread vs Rest Operators",
          "content": "Spread (...) expands arrays/objects into individual elements. Rest (...) collects multiple elements into an array. Example: spread - [...arr1, ...arr2]; rest - function(...args)"
        }
      ],
      "quiz": [
        {
          "id": "js-quiz-1",
          "question": "What will console.log(typeof null) output?",
          "options": ["null", "object", "undefined", "boolean"],
          "correct": 1,
          "explanation": "'typeof null' returns 'object' due to a legacy JavaScript bug. This is a well-known quirk that hasn't been fixed for backwards compatibility."
        },
        {
          "id": "js-quiz-2",
          "question": "Which of the following is NOT a primitive data type in JavaScript?",
          "options": ["string", "number", "boolean", "array"],
          "correct": 3,
          "explanation": "Array is an object type, not a primitive. JavaScript primitives are: string, number, boolean, undefined, null, symbol, and bigint."
        },
        {
          "id": "js-quiz-3",
          "question": "What does 'use strict' do?",
          "options": ["Enables ES6 features", "Makes the code run faster", "Enables stricter parsing and error handling", "Imports external modules"],
          "correct": 2,
          "explanation": "'use strict' enables strict mode, which catches common coding mistakes and prevents the use of potentially problematic features."
        },
        {
          "id": "js-quiz-4",
          "question": "What is the output of: [1, 2, 3].map(x => x * 2).filter(x => x > 3)",
          "options": ["[2, 4, 6]", "[4, 6]", "[4]", "Error"],
          "correct": 1,
          "explanation": "The map function doubles each element to [2, 4, 6], then filter removes elements â‰¤ 3, leaving [4, 6]."
        },
        {
          "id": "js-quiz-5",
          "question": "Which method creates a new array with all elements that pass a test?",
          "options": ["map()", "filter()", "forEach()", "reduce()"],
          "correct": 1,
          "explanation": "filter() creates a new array with all elements that pass the condition specified in the callback function."
        }
      ]
    },
    "web": {
      "name": "Web/Frontend",
      "description": "General web development and frontend concepts",
      "icon": "fas fa-globe",
      "hints": [
        {
          "id": "web-1",
          "title": "CSS Box Model",
          "content": "Every element has content, padding, border, and margin. Total width = content + padding-left + padding-right + border-left + border-right + margin-left + margin-right."
        },
        {
          "id": "web-2",
          "title": "CSS Specificity",
          "content": "Specificity determines which CSS rule applies when multiple rules target the same element. Order: inline styles > IDs > classes/attributes/pseudo-classes > elements/pseudo-elements."
        },
        {
          "id": "web-3",
          "title": "DOM Manipulation",
          "content": "The Document Object Model represents the page structure. You can select elements with getElementById, querySelector, etc., and modify them with properties like innerHTML, style, classList."
        },
        {
          "id": "web-4",
          "title": "Event Bubbling",
          "content": "Events propagate from the target element up to the root. Use event.stopPropagation() to prevent this. Event delegation uses bubbling to handle events on parent elements."
        },
        {
          "id": "web-5",
          "title": "CSS Flexbox",
          "content": "Flexbox is a layout method for arranging items in rows or columns. Use display: flex on container, justify-content for horizontal alignment, align-items for vertical alignment."
        }
      ],
      "quiz": [
        {
          "id": "web-quiz-1",
          "question": "Which CSS property is used to create space between flex items?",
          "options": ["align-items", "justify-content", "gap", "flex-direction"],
          "correct": 2,
          "explanation": "The 'gap' property creates space between flex items, replacing the need for margins in many cases."
        },
        {
          "id": "web-quiz-2",
          "question": "What does CSS specificity 1-0-0 mean?",
          "options": ["1 ID, 0 classes, 0 elements", "1 class, 0 IDs, 0 elements", "1 element, 0 classes, 0 IDs", "Invalid specificity"],
          "correct": 0,
          "explanation": "CSS specificity is calculated as (inline styles, IDs, classes/attributes/pseudo-classes, elements/pseudo-elements)."
        },
        {
          "id": "web-quiz-3",
          "question": "Which method would you use to select the first element with class 'my-class'?",
          "options": ["getElementById", "getElementsByClassName", "querySelector", "querySelectorAll"],
          "correct": 2,
          "explanation": "querySelector returns the first matching element, while querySelectorAll returns a NodeList of all matching elements."
        },
        {
          "id": "web-quiz-4",
          "question": "What is the default position value in CSS?",
          "options": ["relative", "absolute", "static", "fixed"],
          "correct": 2,
          "explanation": "By default, elements have position: static, meaning they flow normally in the document without special positioning."
        },
        {
          "id": "web-quiz-5",
          "question": "Which pseudo-class selects an element when the user hovers over it?",
          "options": ["active", "focus", "hover", "visited"],
          "correct": 2,
          "explanation": ":hover pseudo-class applies styles when the user hovers over an element with the mouse cursor."
        }
      ]
    },
    "vue": {
      "name": "Vue.js",
      "description": "Vue.js framework concepts and best practices",
      "icon": "fab fa-vuejs",
      "hints": [
        {
          "id": "vue-1",
          "title": "Composition API vs Options API",
          "content": "Composition API groups related logic together using composables, making it easier to reuse logic across components. Options API separates concerns by options (data, methods, computed, etc.)."
        },
        {
          "id": "vue-2",
          "title": "Reactivity",
          "content": "Vue's reactivity system tracks changes to data and updates the DOM automatically. Use ref() for primitives and reactive() for objects. Always access ref values with .value in setup."
        },
        {
          "id": "vue-3",
          "title": "Lifecycle Hooks",
          "content": "onMounted, onUpdated, onUnmounted are the main lifecycle hooks in Composition API. Options API uses mounted, updated, beforeUnmount, etc. Use these to run code at specific points in component lifecycle."
        },
        {
          "id": "vue-4",
          "title": "Computed Properties",
          "content": "Computed properties cache their result and only recalculate when dependencies change. Use them for derived state that depends on reactive data. They're more efficient than methods for expensive operations."
        },
        {
          "id": "vue-5",
          "title": "Props and Emits",
          "content": "Props are reactive data passed from parent to child. Define them with prop types for validation. Emits are events sent from child to parent. Use defineEmits to declare them in Composition API."
        }
      ],
      "quiz": [
        {
          "id": "vue-quiz-1",
          "question": "Which function is used to create reactive data in Vue 3 Composition API?",
          "options": ["reactive()", "ref()", "computed()", "Both A and B"],
          "correct": 3,
          "explanation": "Both reactive() and ref() create reactive data. reactive() is for objects, ref() is for any value type."
        },
        {
          "id": "vue-quiz-2",
          "question": "What is the correct way to access a ref's value in a Vue template?",
          "options": ["{{ myRef }}", "{{ myRef.value }}", "{{ $refs.myRef }}", "{{ myRef() }}"],
          "correct": 1,
          "explanation": "In templates, refs are automatically unwrapped, so you access {{ myRef }} directly, not {{ myRef.value }}."
        },
        {
          "id": "vue-quiz-3",
          "question": "Which lifecycle hook runs after the component is inserted into the DOM?",
          "options": ["onBeforeMount", "onMounted", "onUpdated", "onUnmounted"],
          "correct": 1,
          "explanation": "onMounted runs after the component is inserted into the DOM and is ready for DOM manipulation."
        },
        {
          "id": "vue-quiz-4",
          "question": "What does the 'key' attribute do in v-for loops?",
          "options": ["Improves performance", "Helps Vue track which items changed", "Both A and B", "None of the above"],
          "correct": 2,
          "explanation": "The key attribute helps Vue identify which items have changed, been added, or removed, improving performance and preventing bugs."
        },
        {
          "id": "vue-quiz-5",
          "question": "Which directive is used for conditional rendering in Vue?",
          "options": ["v-show", "v-if", "v-else", "All of the above"],
          "correct": 3,
          "explanation": "v-if, v-else-if, and v-else are used for conditional rendering. v-show toggles visibility with CSS display property."
        }
      ]
    },
    "react": {
      "name": "React",
      "description": "React framework concepts and hooks",
      "icon": "fab fa-react",
      "hints": [
        {
          "id": "react-1",
          "title": "useState Hook",
          "content": "useState returns an array with current state and setter function. Use array destructuring: const [count, setCount] = useState(0). State updates are asynchronous."
        },
        {
          "id": "react-2",
          "title": "useEffect Hook",
          "content": "useEffect runs after render and can handle side effects. Pass empty array [] as second argument to run only once (componentDidMount). Return cleanup function for componentWillUnmount."
        },
        {
          "id": "react-3",
          "title": "Props",
          "content": "Props are read-only data passed from parent to child components. Use them to make components reusable. Destructure props in function parameters for cleaner code."
        },
        {
          "id": "react-4",
          "title": "Keys in Lists",
          "content": "Keys help React identify which items have changed, been added, or removed. Use unique, stable identifiers (like IDs) rather than array indices for better performance."
        },
        {
          "id": "react-5",
          "title": "Custom Hooks",
          "content": "Custom hooks let you extract component logic into reusable functions. They start with 'use' and can call other hooks. Use them to share stateful logic between components."
        }
      ],
      "quiz": [
        {
          "id": "react-quiz-1",
          "question": "When does useEffect run by default?",
          "options": ["After every render", "Only on component mount", "Only on component unmount", "Never"],
          "correct": 0,
          "explanation": "useEffect runs after every completed render, including the initial render. Use dependency array to control when it runs."
        },
        {
          "id": "react-quiz-2",
          "question": "What is the correct way to update state based on previous state?",
          "options": ["setCount(count + 1)", "setCount(prevCount => prevCount + 1)", "Both are correct", "Neither is correct"],
          "correct": 2,
          "explanation": "Both approaches work, but using the functional update form ensures you're working with the latest state value."
        },
        {
          "id": "react-quiz-3",
          "question": "Which hook is used to perform side effects in functional components?",
          "options": ["useState", "useEffect", "useContext", "useReducer"],
          "correct": 1,
          "explanation": "useEffect is the primary hook for handling side effects like API calls, subscriptions, and DOM manipulation."
        },
        {
          "id": "react-quiz-4",
          "question": "What happens if you don't provide a key prop when rendering a list?",
          "options": ["React will throw an error", "Performance may suffer", "React will use array indices as keys", "Nothing"],
          "correct": 2,
          "explanation": "React will use array indices as keys if none are provided, but this can cause performance issues and bugs with list reordering."
        },
        {
          "id": "react-quiz-5",
          "question": "Which lifecycle method is equivalent to useEffect with an empty dependency array?",
          "options": ["componentDidMount", "componentDidUpdate", "componentWillUnmount", "componentWillUpdate"],
          "correct": 0,
          "explanation": "useEffect with empty dependency array [] runs only once after the initial render, equivalent to componentDidMount."
        }
      ]
    },
    "angular": {
      "name": "Angular",
      "description": "Angular framework concepts and best practices",
      "icon": "fab fa-angular",
      "hints": [
        {
          "id": "angular-1",
          "title": "Components vs Directives",
          "content": "Components are directives with a template. Components control a portion of the screen called a view. Directives are instructions in the DOM - structural directives (ngIf, ngFor) change DOM layout, attribute directives (ngStyle, ngClass) change appearance/behavior."
        },
        {
          "id": "angular-2",
          "title": "Dependency Injection",
          "content": "Angular's DI system provides dependencies to components. Use @Injectable() decorator for services. Inject dependencies in constructor parameters. Angular creates singletons for services by default. Use providedIn: 'root' for automatic tree-shaking."
        },
        {
          "id": "angular-3",
          "title": "Change Detection",
          "content": "Angular uses zone.js to detect changes. OnPush strategy checks for changes only when input properties change or events are explicitly triggered. Use async pipe for observables, trackBy function for ngFor to optimize performance."
        },
        {
          "id": "angular-4",
          "title": "RxJS & Observables",
          "content": "Angular heavily uses RxJS for reactive programming. Use Observable for async operations. Common operators: map, filter, tap, switchMap, combineLatest. Subscribe in ngOnInit, unsubscribe in ngOnDestroy to prevent memory leaks."
        },
        {
          "id": "angular-5",
          "title": "Angular CLI Commands",
          "content": "ng new creates new app, ng generate component/directive/service/pipe creates code. ng serve starts dev server, ng build builds for production. ng test runs unit tests, ng e2e runs end-to-end tests. Use --skip-tests to skip test files."
        }
      ],
      "quiz": [
        {
          "id": "angular-quiz-1",
          "question": "What is the purpose of the @Component decorator in Angular?",
          "options": ["To define a service", "To mark a class as a component and provide metadata", "To create a directive", "To handle HTTP requests"],
          "correct": 1,
          "explanation": "The @Component decorator tells Angular that the class is a component and provides configuration metadata including selector, template, and styles."
        },
        {
          "id": "angular-quiz-2",
          "question": "Which directive is used for two-way data binding in Angular?",
          "options": ["[property]", "(event)", "[(ngModel)]", "*ngIf"],
          "correct": 2,
          "explanation": "[(ngModel)] is the two-way data binding syntax in Angular. It combines property binding [] and event binding () for bidirectional data flow."
        },
        {
          "id": "angular-quiz-3",
          "question": "What is the correct way to inject a service in Angular?",
          "options": ["Using constructor injection", "Using property injection", "Using setter injection", "All of the above"],
          "correct": 0,
          "explanation": "Angular recommends constructor injection for services. Add the service as a parameter in the component constructor, and Angular's DI system will provide the instance."
        },
        {
          "id": "angular-quiz-4",
          "question": "Which lifecycle hook is called after Angular has initialized all data-bound properties?",
          "options": ["ngOnInit", "ngAfterViewInit", "ngOnChanges", "ngAfterContentInit"],
          "correct": 0,
          "explanation": "ngOnInit is called once after the first ngOnChanges and is the ideal place to initialize component data, fetch data from services, and set up subscriptions."
        },
        {
          "id": "angular-quiz-5",
          "question": "What is the purpose of the async pipe in Angular?",
          "options": ["To handle asynchronous operations", "To subscribe to observables automatically", "To prevent memory leaks", "Both B and C"],
          "correct": 3,
          "explanation": "The async pipe subscribes to an Observable or Promise automatically and returns the latest value. It also unsubscribes when the component is destroyed, preventing memory leaks."
        }
      ]
    }
  }
}
